
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>浅谈mock和stub - Jun Lee&#8217;s Blog</title>
	<meta name="author" content="Jun Lee">

	
	<meta name="description" content="要给人讲解mock和stub的区别，才发现自己只是有个模糊的概念，索性系统整理下，算是总结也算是对自己的检验。 作为一个测试的基本概念，mock和stub在测试中使用的很多，尤其在单元测试中，在我的理解里，无论mock还是stub,都是对系统隔离的手段（或者粒度更小一些，对模块、单元隔离）。 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Jun Lee's Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<!--  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script> &#8211;>
	<script src="/javascripts/libs/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">Jun Lee&#8217;s Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:apollojoke.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		<a class="twitter" href="http://twitter.com/LiJun4454" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/apollojoke" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:apollojoke.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">浅谈mock和stub</h2>
	<div class="entry-content"><p>要给人讲解mock和stub的区别，才发现自己只是有个模糊的概念，索性系统整理下，算是总结也算是对自己的检验。</p>

<p>作为一个测试的基本概念，mock和stub在测试中使用的很多，尤其在单元测试中，在我的理解里，无论mock还是stub,都是对系统隔离的手段（或者粒度更小一些，对模块、单元隔离）。</p>

<p>所谓隔离就是，在单元测试中，尤其是单元测试中，我们只关注被测单元本身自己的逻辑（功能和行为），应该尽可能的独立，对于它所依赖的模块，我们不是非常关心，充其量只关心依赖与被测单元的交互，例如：是否调用，合适调用，调用的参数，次数和顺序等，以及返回的结果或者是否发生异常，我们很少关注依赖本身的实现细节，因此常见的技巧就是用mock或者stub创建自己的对象，来代替依赖，然后按照测试的需要控制这个对象的行为。</p>

<p>我理解中，stub和mock的区别可以表示为  mock = stub + 对交互行为的预期。</p>

<p>何为交互行为的预期，例如，某个方法是否被调用，调用了几次，调用顺序如何等等。</p>

<p>首先看一段代码：</p>

<pre><code>    public interface UserService {
        User query(String userId);
    }

    public class UserServiceImpl implements UserService {
        private UserDao userDao; 
        public User query(String userId) {
            return userDao.getById(userId);
        }
        //setter for userDao
    }

    public interface UserDao {
        User getById(String userId);
    }
</code></pre>

<p>stub的标准实现，需要自己实现一个类并实现方法:</p>

<pre><code>    public class UserDaoStub implements UserDao {
        public User getById(String id) {
            User user = new User();
            user.set.....
            return user;
        }
    }


    @Test
    public void testGetById() {
        UserServiceImpl service = new UserServiceImpl();
        UserDao userDao  = new UserDaoStub(); //直接new一个stub的对象
        service.setUserDao(userDao);

        User user = service.query("1001");
        ...
    }
</code></pre>

<p>mock的实现，以mockito为例，只要指定mock的类并指定期望的行为，并没有显式的构造新类:</p>

<pre><code>    @Test
    public void testGetById() {
        UserDao dao = mock(UserDao.class);
        User user = new User();
        user.set.....
        when(dao.getById("1001")).thenReturn(user);

        UserServiceImpl service = new UserServiceImpl();
        service.setUserDao(userDao);
        User user = service.query("1001");
        ...
        verify(dao).getById("1001")；
    }
</code></pre>

<p>所以可以看出，有如下几个不同点，</p>

<ol>
<li><p>从类实现的方式上看，大部分情况，stub有一个显示的类实现，可以为普通类（被多个测试文件复用），内部类（一个测试文件的多个测试方法复用），乃至内部匿名类（只用于当前测试方法），stub方法也会有具体的实现，哪怕逻辑假到只有一个return。mock则不同，mock的实现类通常是有mock工具（例如easymock,mockito）来隐式实现，具体mock的方法行为则通过record方式指定（不是实现）。当然，并不是说被mock工具创建的就是mock对象，如果不关注交互行为，一样是stub对象。</p>

<p> 可见，创建一个stub对象，可以自己显示定义一个类，也可以用mock工具创建，想把它变成mock对象，关注它的交互行为。</p></li>
<li><p>从测试逻辑的可读性上看，mock的做法通常在测试代码中直接mock类的定义和方法行为，测试代码和mock代码通常放一起，所以测试逻辑可读性高。<code>when(dao.getById("1001")).thenReturn(user);</code>直接了当的指明对UserDao这个依赖的预期，getById需要被调用，调用的参数是“1001”，调用次数是1。</p>

<p> 而stub的测试用例中，只有简单的<code>UserDao userDao  = new UserDaoStub();</code> 和<code>service.setUserDao(userDao);</code> 无法从测试用例中直接看出对依赖的预期。所以当stub数量多或行为复杂的情况下，测试逻辑可读性就会下降。</p></li>
<li><p>从可复用的角度看，mock很少考虑复用，每个mock对象都遵循着‘just enough’原则，在测试用例中实现自己的mock逻辑 ，当然在同一个测试类中简单的初始化逻辑也在复用。（何为简单初始化，这里也就是stub和mock边界模糊的体现）</p>

<p> stub显示的类定义，所以复用方便，尤其是一些通用的stub，spring框架就为此提供了大量的stub来方便测试，不过很遗憾的是，它的名字用错了：spring-mock！</p></li>
<li><p>最重要的不同是对交互行为的期望，对于mock来说，我们期待方法有没有被调用，调用的次数，期待适当的参数，甚至是mock之间的调用顺序，所有的一切被事先准备好，测试结束后验证是否和预期的一致。mock关注这个交互的过程！</p>

<p> 而stub，从例子看出，没有代码来帮助判断这个stub类是否被调用，仅只是捏造了一个功能上替代依赖的对象。stub关注的是输入输出，要的是那个捏造的结果。（理论上Stub可以用自己的编码实现mock的期望，例如增加一个计数器，每次调用+1，实际上很少这么用。）</p></li>
</ol>


<p>在实际开发过程中，mock和stub的界限有时候很模糊，并没有严格的划分。</p>

<p>主要原因是，现实使用中，我们经常将mock做不同程度的退化，通过anyObject()放宽参数的检查，anyTimes()放宽调用次数的检查，这某种程度上就想stub一样的工作了。同样的Stub也能通过自身的编码来实现mock的特性，从而使得两者的界限更加模糊。</p>

<p>本文参考<a href="http://www.blogjava.net/aoxj/archive/2010/08/26/329975.html">链接</a></p>
</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-11-27T21:28:07+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/fake/'>fake</a>, <a class='category' href='/blog/categories/mock/'>mock</a>, <a class='category' href='/blog/categories/stub/'>stub</a>, <a class='category' href='/blog/categories/unittest/'>unittest</a>


</div>
	
	<div class="comments"><a href="#disqus_thread">Comments</a></div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		<a class="addthis_button_tweet"></a>
		
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    Jun Lee

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'apollojoke';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://apollojoke.github.io/blog/2014/11/27/qian-tan-mockhe-stub/';
        var disqus_url = 'http://apollojoke.github.io/blog/2014/11/27/qian-tan-mockhe-stub/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-55204094-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


<script type="text/javascript">
	$(document).ready(function () {
  		$('.entry-content').each(function(){
  			$(this).html($(this).html().slice(0,100)).append("...");
		});
	});
</script>
</body>
</html>